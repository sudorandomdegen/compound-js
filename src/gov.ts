import { ethers } from 'ethers';
import * as eth from './eth';
import { netId } from './helpers';
import { address, abi } from './constants';

/**
 * Submit a vote on a Compound Governance proposal.
 *
 * @param {String} proposalId The ID of the proposal to vote on. This is an
 *     auto-incrementing integer in the Governor Alpha contract.
 *
 * @returns {object} Returns an Ethers.js transaction object of the vote
 *     transaction.
 */
export async function castVote(proposalId: number, support: boolean, options: any = {}) {
  await netId(this);

  const errorPrefix = 'Compound [castVote] | ';

  if (typeof proposalId !== 'number') {
    throw Error(errorPrefix + 'Argument `proposalId` must be an integer.');
  }

  if (typeof support !== 'boolean') {
    throw Error(errorPrefix + 'Argument `support` must be a boolean.');
  }

  const governorAddress = address[this._network.name].GovernorAlpha;
  const trxOptions: any = {
    _compoundProvider: this._provider,
    abi: abi.GovernorAlpha,
  };
  const parameters = [ proposalId, support ];
  const method = 'castVote';

  return eth.trx(governorAddress, method, parameters, trxOptions);
}

/**
 * Submit a vote on a Compound Governance proposal using a EIP-712 signature.
 *
 * @param {String} proposalId The ID of the proposal to vote on. This is an
 *     auto-incrementing integer in the Governor Alpha contract.
 * @param {Boolean} support A boolean of true for 'yes' or false for 'no' on the
 *     proposal vote.
 * @param {Object} signature An object that contains the v, r, and, s values of
 *     an EIP-712 signature.
 * @param {CallOptions} [options] Options to set for `eth_call`, optional ABI
 *     (as JSON object), and ethers.js method overrides. The ABI can be a string
 *     of the single intended method, an array of many methods, or a JSON object
 *     of the ABI generated by a Solidity compiler.
 *
 * @returns {object} Returns an Ethers.js transaction object of the vote
 *     transaction.
 */
export async function castVoteBySig(
  proposalId: number,
  support: boolean,
  signature: any = {},
  options: any = {}
) {
  await netId(this);

  const errorPrefix = 'Compound [castVoteBySig] | ';

  if (typeof proposalId !== 'number') {
    throw Error(errorPrefix + 'Argument `proposalId` must be an integer.');
  }

  if (typeof support !== 'boolean') {
    throw Error(errorPrefix + 'Argument `support` must be a boolean.');
  }

  if (
    !Object.isExtensible(signature) ||
    !signature.v ||
    !signature.r ||
    !signature.s
  ) {
    throw Error(errorPrefix + 'Argument `signature` must be an object that ' + 
      'contains the v, r, and s pieces of an EIP-712 signature.');
  }

  const governorAddress = address[this._network.name].GovernorAlpha;
  const trxOptions: any = {
    _compoundProvider: this._provider,
    abi: abi.GovernorAlpha,
  };
  const { v, r, s } = signature;
  const parameters = [ proposalId, support, v, r, s ];
  const method = 'castVoteBySig';

  return eth.trx(governorAddress, method, parameters, trxOptions);
}

// /**
//  * Description.
//  *
//  * @param {String} var Description
//  *
//  * @returns {object} Returns an Ethers.js transaction object of the vote
//  *     transaction.
//  */
// export async function createVoteSignature(proposalId: number) {
//   await netId(this);

//   const errorPrefix = 'Compound [createVoteSignature] | ';

//   if (typeof proposalId !== 'number') {
//     throw Error(errorPrefix + 'Argument `proposalId` must be an integer.');
//   }

//   const _address = this._provider.address;
//   const chainId = this._network.id;
//   const governorAddress = address[this._network.name].GovernorAlpha;

//   const msgParamsFor = createVoteBySigMessage(governorAddress, proposalId, true, chainId);
//   const msgParamsAgainst = createVoteBySigMessage(governorAddress, proposalId, false, chainId);

//   // const sigFor = await web3SignTypedData(provider, _address, msgParamsFor);
//   // const sigAgainst = await web3SignTypedData(provider, _address, msgParamsAgainst);

//   let sigFor, sigAgainst;
//   try {
//     window;
//     // const provider = web3.currentProvider;
//     sigFor = await web3SignTypedData(provider, _address, msgParamsFor);
//     sigAgainst = await web3SignTypedData(provider, _address, msgParamsAgainst);
//   } catch(e) {
//     // do node js version here
//   }

//   return { for: sigFor, against: sigAgainst };
// }

function createVoteBySigMessage (govAddress: string, proposalId: number, support: boolean, chainId: number = 1) {
  const types = {
    EIP712Domain: [
      { name: 'name', type: 'string' },
      { name: 'chainId', type: 'uint256' },
      { name: 'verifyingContract', type: 'address' },
    ],
    Ballot: [
      { name: 'proposalId', type: 'uint256' },
      { name: 'support', type: 'bool' }
    ]
  };

  const primaryType = 'Ballot';
  const domain = { name: 'Compound Governor Alpha', chainId, verifyingContract: govAddress };
  support = !!support;
  const message = { proposalId, support };

  return JSON.stringify({ types, primaryType, domain, message });
};

function web3SignTypedData (provider: any, fromAddress: string, messageParams: string) {
  return new Promise((resolve, reject) => {
    provider.sendAsync({
      method: 'eth_signTypedData_v4',
      params: [ fromAddress, messageParams ],
      from: fromAddress
    }, async (err, result) => {
      if (err) {
        reject(err);
      } else if (result.error) {
        reject(result.error.message);
      } else {
        resolve(result.result);
      }
    });
  });
};
